Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:

answer[i] % answer[j] == 0, or
answer[j] % answer[i] == 0
If there are multiple solutions, return any of them.

Example 1:

Input: nums = [1,2,3]
Output: [1,2]
Explanation: [1,3] is also accepted.
Example 2:

Input: nums = [1,2,4,8]
Output: [1,2,4,8]

Approach : 
              ( This is same as longest increasing subsequences but the condition is changed over  based on the question expects ) 
Memoization 

Time complexity : O(N*N)
Space complexity : O(N*N) + O(N) 

#include<bits/stdc++.h>
using namespace std;

int helper(vector<int>&nums,int ind,vector<int>&temp,vector<vector<int>>&dp,int prev_Ind,vector<int>&res)
{
    //base case
     if(ind==nums.size())
     {
        //  for(int i=0;i<temp.size();i++)
        //  cout<<temp[i]<<" ";
         
        //  cout<<endl;
        
        if(temp.size()>res.size())   res=temp;
           
        return temp.size();
     }
        
        if(dp[ind][prev_Ind+1]!=-1)  return dp[ind][prev_Ind+1];
        
        int pick=0;
    //pick case
     if(temp.size()==0 || nums[ind]%temp.back()==0)
     {
         temp.push_back(nums[ind]);
         pick=helper(nums,ind+1,temp,dp,ind,res);
         temp.pop_back();
     }
      //not pick case
     int notPick=helper(nums,ind+1,temp,dp,prev_Ind,res);
     return dp[ind][prev_Ind+1]=max(pick,notPick);
}
int main()
{
    vector<int>nums{1,2,3};
    int n=nums.size();
    vector<int>temp;
    vector<int> res;
    vector<vector<int>>dp(n,vector<int>(n,-1));
    cout<<helper(nums,0,temp,dp,-1,res);
    cout<<endl;
    cout<<"Largest divisible subset is :  ";
       for(int i=0;i<res.size();i++)
    {   
            cout<<res[i]<<"  ";  
    }
    return 0;
}

Approach : Tabulation

 vector<int> largestDivisibleSubset(vector<int>& nums) {
          
   
          sort(nums.begin(),nums.end());
 
       if(nums.size()<=1)
        return nums;

        int n=nums.size();
        vector<int>count(n,1);
        vector<int>indices;
        for(int i=0;i<n;i++)
        indices.push_back(i);
         
         int maxCount=0;
         int maxCountIndex=-1;

        //now we have the count  -> 1 , 1 , 1, 1, 1
        //indices  -> 0 1 2 3 4 5


        //traverse through the array and find the indices
        for(int i=0;i<n;i++)
        {
            for(int pInd=0;pInd<i;pInd++)
            {
                if(nums[i]%nums[pInd]==0 || nums[pInd]%nums[i]==0)
                {
                    //check the current count is greater than prevCount
                    //if that true then change in indices
                    int prevCount=count[i];
                    int currCount=count[pInd]+1;
                    if(prevCount<currCount)
                    {
                       count[i]=currCount;  //-> updating the new count 
                       indices[i]=pInd;  //-> mapping to the new index which give max  subset                 
                       if(maxCount<count[i])
                       {
                        maxCount=count[i];
                        maxCountIndex=i;
                       }
                    }
                }
            }
        }

        vector<int>result;
        int index=maxCountIndex;

          if(index==-1)
            return {nums[0]};

      
        
        //store that 
        while(true)
        {
            int nextIndex=indices[index];
            if(nextIndex==index)
            {
               result.push_back(nums[index]);
               break;
            }

            result.push_back(nums[index]);
            index=nextIndex; 

        }

        return result;
    }
};
